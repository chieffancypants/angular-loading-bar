{
  "version": 3,
  "sources": [
    "webpack:///webpack/universalModuleDefinition?5ca6",
    "webpack:///loading-bar.js",
    "webpack:///webpack/bootstrap e4cc23821687654fd1e6?cdf9",
    "webpack:///external \"angular\"",
    "webpack:///./src/loading-bar.js"
  ],
  "names": [
    "root",
    "factory",
    "exports",
    "module",
    "require",
    "define",
    "amd",
    "this",
    "__WEBPACK_EXTERNAL_MODULE_1__",
    "modules",
    "__webpack_require__",
    "moduleId",
    "installedModules",
    "i",
    "l",
    "call",
    "m",
    "c",
    "value",
    "d",
    "name",
    "getter",
    "o",
    "Object",
    "defineProperty",
    "configurable",
    "enumerable",
    "get",
    "n",
    "__esModule",
    "object",
    "property",
    "prototype",
    "hasOwnProperty",
    "p",
    "s",
    "1",
    "8",
    "angular",
    "config",
    "$httpProvider",
    "interceptor",
    "$q",
    "$cacheFactory",
    "$timeout",
    "$rootScope",
    "$log",
    "cfpLoadingBar",
    "setComplete",
    "cancel",
    "startTimeout",
    "complete",
    "reqsCompleted",
    "reqsTotal",
    "isCached",
    "cache",
    "defaultCache",
    "defaults",
    "method",
    "isObject",
    "cached",
    "undefined",
    "url",
    "latencyThreshold",
    "request",
    "ignoreLoadingBar",
    "$broadcast",
    "start",
    "set",
    "response",
    "result",
    "error",
    "responseError",
    "rejection",
    "reject",
    "interceptors",
    "push",
    "provider",
    "autoIncrement",
    "includeSpinner",
    "includeBar",
    "startSize",
    "parentSelector",
    "spinnerTemplate",
    "loadingBarTemplate",
    "$get",
    "$injector",
    "$document",
    "_start",
    "$animate",
    "completeTimeout",
    "started",
    "document",
    "parent",
    "querySelector",
    "$parentSelector",
    "find",
    "getElementsByTagName",
    "$parent",
    "element",
    "$after",
    "lastChild",
    "enter",
    "loadingBarContainer",
    "spinner",
    "_set",
    "pct",
    "loadingBar",
    "css",
    "status",
    "incTimeout",
    "_inc",
    "_status",
    "rnd",
    "stat",
    "Math",
    "random",
    "_completeAnimation",
    "_complete",
    "promise",
    "leave",
    "then",
    "eq",
    "inc"
  ],
  "mappings": "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",
  "file": "loading-bar.js",
  "sourcesContent": [
    "(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"angular-loading-bar\"] = factory(require(\"angular\"));\n\telse\n\t\troot[\"angular-loading-bar\"] = factory(root[\"angular\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition",
    "(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"angular-loading-bar\"] = factory(require(\"angular\"));\n\telse\n\t\troot[\"angular-loading-bar\"] = factory(root[\"angular\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 8);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 1:\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }),\n\n/***/ 8:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*\n * angular-loading-bar\n *\n * intercepts XHR requests and creates a loading bar.\n * Based on the excellent nprogress work by rstacruz (more info in readme)\n *\n * (c) 2013 Wes Cruver\n * License: MIT\n */\n\n\n\nvar angular = __webpack_require__(1);\n\nvar MODULE_NAME = \"angular-loading-bar\";\n// Alias the loading bar for various backwards compatibilities since the project has matured:\nangular.module(MODULE_NAME, ['cfp.loadingBarInterceptor']);\nangular.module('chieffancypants.loadingBar', ['cfp.loadingBarInterceptor']);\n\n\n/**\n * loadingBarInterceptor service\n *\n * Registers itself as an Angular interceptor and listens for XHR requests.\n */\nangular.module('cfp.loadingBarInterceptor', ['cfp.loadingBar'])\n  .config(['$httpProvider', function ($httpProvider) {\n  \n    var interceptor = ['$q', '$cacheFactory', '$timeout', '$rootScope', '$log', 'cfpLoadingBar', function ($q, $cacheFactory, $timeout, $rootScope, $log, cfpLoadingBar) {\n    \n      /**\n       * The total number of requests made\n       */\n      var reqsTotal = 0;\n    \n      /**\n       * The number of requests completed (either successfully or not)\n       */\n      var reqsCompleted = 0;\n    \n      /**\n       * The amount of time spent fetching before showing the loading bar\n       */\n      var latencyThreshold = cfpLoadingBar.latencyThreshold;\n    \n      /**\n       * $timeout handle for latencyThreshold\n       */\n      var startTimeout;\n    \n    \n      /**\n       * calls cfpLoadingBar.complete() which removes the\n       * loading bar from the DOM.\n       */\n      function setComplete() {\n        $timeout.cancel(startTimeout);\n        cfpLoadingBar.complete();\n        reqsCompleted = 0;\n        reqsTotal = 0;\n      }\n    \n      /**\n       * Determine if the response has already been cached\n       * @param  {Object}  config the config option from the request\n       * @return {Boolean} retrns true if cached, otherwise false\n       */\n      function isCached(config) {\n        var cache;\n        var defaultCache = $cacheFactory.get('$http');\n        var defaults = $httpProvider.defaults;\n      \n        // Choose the proper cache source. Borrowed from angular: $http service\n        if ((config.cache || defaults.cache) && config.cache !== false &&\n          (config.method === 'GET' || config.method === 'JSONP')) {\n          cache = angular.isObject(config.cache) ? config.cache\n            : angular.isObject(defaults.cache) ? defaults.cache\n              : defaultCache;\n        }\n      \n        var cached = cache !== undefined ?\n          cache.get(config.url) !== undefined : false;\n      \n        if (config.cached !== undefined && cached !== config.cached) {\n          return config.cached;\n        }\n        config.cached = cached;\n        return cached;\n      }\n    \n    \n      return {\n        'request': function (config) {\n          // Check to make sure this request hasn't already been cached and that\n          // the requester didn't explicitly ask us to ignore this request:\n          if (!config.ignoreLoadingBar && !isCached(config)) {\n            $rootScope.$broadcast('cfpLoadingBar:loading', {url: config.url});\n            if (reqsTotal === 0) {\n              startTimeout = $timeout(function () {\n                cfpLoadingBar.start();\n              }, latencyThreshold);\n            }\n            reqsTotal++;\n            cfpLoadingBar.set(reqsCompleted / reqsTotal);\n          }\n          return config;\n        },\n      \n        'response': function (response) {\n          if (!response || !response.config) {\n            $log.error('Broken interceptor detected: Config object not supplied in response:\\n https://github.com/chieffancypants/angular-loading-bar/pull/50');\n            return response;\n          }\n        \n          if (!response.config.ignoreLoadingBar && !isCached(response.config)) {\n            reqsCompleted++;\n            if (reqsCompleted >= reqsTotal) {\n              $rootScope.$broadcast('cfpLoadingBar:loaded', {url: response.config.url, result: response});\n              setComplete();\n            } else {\n              cfpLoadingBar.set(reqsCompleted / reqsTotal);\n            }\n          }\n          return response;\n        },\n      \n        'responseError': function (rejection) {\n          if (!rejection || !rejection.config) {\n            $log.error('Broken interceptor detected: Config object not supplied in rejection:\\n https://github.com/chieffancypants/angular-loading-bar/pull/50');\n            return $q.reject(rejection);\n          }\n        \n          if (!rejection.config.ignoreLoadingBar && !isCached(rejection.config)) {\n            reqsCompleted++;\n            if (reqsCompleted >= reqsTotal) {\n              $rootScope.$broadcast('cfpLoadingBar:loaded', {url: rejection.config.url, result: rejection});\n              setComplete();\n            } else {\n              cfpLoadingBar.set(reqsCompleted / reqsTotal);\n            }\n          }\n          return $q.reject(rejection);\n        }\n      };\n    }];\n  \n    $httpProvider.interceptors.push(interceptor);\n  }]);\n\n\n/**\n * Loading Bar\n *\n * This service handles adding and removing the actual element in the DOM.\n * Generally, best practices for DOM manipulation is to take place in a\n * directive, but because the element itself is injected in the DOM only upon\n * XHR requests, and it's likely needed on every view, the best option is to\n * use a service.\n */\nangular.module('cfp.loadingBar', [])\n  .provider('cfpLoadingBar', function () {\n    \n    this.autoIncrement = true;\n    this.includeSpinner = true;\n    this.includeBar = true;\n    this.latencyThreshold = 100;\n    this.startSize = 0.02;\n    this.parentSelector = 'body';\n    this.spinnerTemplate = '<div id=\"loading-bar-spinner\"><div class=\"spinner-icon\"></div></div>';\n    this.loadingBarTemplate = '<div id=\"loading-bar\"><div class=\"bar\"><div class=\"peg\"></div></div></div>';\n    \n    this.$get = ['$injector', '$document', '$timeout', '$rootScope', function ($injector, $document, $timeout, $rootScope) {\n      var $animate;\n      var $parentSelector = this.parentSelector,\n        loadingBarContainer = angular.element(this.loadingBarTemplate),\n        loadingBar = loadingBarContainer.find('div').eq(0),\n        spinner = angular.element(this.spinnerTemplate);\n      \n      var incTimeout,\n        completeTimeout,\n        started = false,\n        status = 0;\n      \n      var autoIncrement = this.autoIncrement;\n      var includeSpinner = this.includeSpinner;\n      var includeBar = this.includeBar;\n      var startSize = this.startSize;\n      \n      /**\n       * Inserts the loading bar element into the dom, and sets it to 2%\n       */\n      function _start() {\n        if (!$animate) {\n          $animate = $injector.get('$animate');\n        }\n        \n        $timeout.cancel(completeTimeout);\n        \n        // do not continually broadcast the started event:\n        if (started) {\n          return;\n        }\n        \n        var document = $document[0];\n        var parent = document.querySelector ?\n            document.querySelector($parentSelector)\n            : $document.find($parentSelector)[0]\n          ;\n        \n        if (!parent) {\n          parent = document.getElementsByTagName('body')[0];\n        }\n        \n        var $parent = angular.element(parent);\n        var $after = parent.lastChild && angular.element(parent.lastChild);\n        \n        $rootScope.$broadcast('cfpLoadingBar:started');\n        started = true;\n        \n        if (includeBar) {\n          $animate.enter(loadingBarContainer, $parent, $after);\n        }\n        \n        if (includeSpinner) {\n          $animate.enter(spinner, $parent, loadingBarContainer);\n        }\n        \n        _set(startSize);\n      }\n      \n      /**\n       * Set the loading bar's width to a certain percent.\n       *\n       * @param n any value between 0 and 1\n       */\n      function _set(n) {\n        if (!started) {\n          return;\n        }\n        var pct = (n * 100) + '%';\n        loadingBar.css('width', pct);\n        status = n;\n        \n        // increment loadingbar to give the illusion that there is always\n        // progress but make sure to cancel the previous timeouts so we don't\n        // have multiple incs running at the same time.\n        if (autoIncrement) {\n          $timeout.cancel(incTimeout);\n          incTimeout = $timeout(function () {\n            _inc();\n          }, 250);\n        }\n      }\n      \n      /**\n       * Increments the loading bar by a random amount\n       * but slows down as it progresses\n       */\n      function _inc() {\n        if (_status() >= 1) {\n          return;\n        }\n        \n        var rnd = 0;\n        \n        // TODO: do this mathmatically instead of through conditions\n        \n        var stat = _status();\n        if (stat >= 0 && stat < 0.25) {\n          // Start out between 3 - 6% increments\n          rnd = (Math.random() * (5 - 3 + 1) + 3) / 100;\n        } else if (stat >= 0.25 && stat < 0.65) {\n          // increment between 0 - 3%\n          rnd = (Math.random() * 3) / 100;\n        } else if (stat >= 0.65 && stat < 0.9) {\n          // increment between 0 - 2%\n          rnd = (Math.random() * 2) / 100;\n        } else if (stat >= 0.9 && stat < 0.99) {\n          // finally, increment it .5 %\n          rnd = 0.005;\n        } else {\n          // after 99%, don't increment:\n          rnd = 0;\n        }\n        \n        var pct = _status() + rnd;\n        _set(pct);\n      }\n      \n      function _status() {\n        return status;\n      }\n      \n      function _completeAnimation() {\n        status = 0;\n        started = false;\n      }\n      \n      function _complete() {\n        if (!$animate) {\n          $animate = $injector.get('$animate');\n        }\n        \n        _set(1);\n        $timeout.cancel(completeTimeout);\n        \n        // Attempt to aggregate any start/complete calls within 500ms:\n        completeTimeout = $timeout(function () {\n          var promise = $animate.leave(loadingBarContainer, _completeAnimation);\n          if (promise && promise.then) {\n            promise.then(_completeAnimation);\n          }\n          $animate.leave(spinner);\n          $rootScope.$broadcast('cfpLoadingBar:completed');\n        }, 500);\n      }\n      \n      return {\n        start: _start,\n        set: _set,\n        status: _status,\n        inc: _inc,\n        complete: _complete,\n        autoIncrement: this.autoIncrement,\n        includeSpinner: this.includeSpinner,\n        latencyThreshold: this.latencyThreshold,\n        parentSelector: this.parentSelector,\n        startSize: this.startSize\n      };\n      \n      \n    }];     //\n  });\n\nmodule.exports = MODULE_NAME;\n\n\n/***/ })\n\n/******/ });\n});\n\n\n// WEBPACK FOOTER //\n// loading-bar.js",
    " \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e4cc23821687654fd1e6",
    "module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"angular\"\n// module id = 1\n// module chunks = 1",
    "/*\n * angular-loading-bar\n *\n * intercepts XHR requests and creates a loading bar.\n * Based on the excellent nprogress work by rstacruz (more info in readme)\n *\n * (c) 2013 Wes Cruver\n * License: MIT\n */\n\n'use strict';\n\nvar angular = require('angular');\n\nvar MODULE_NAME = \"angular-loading-bar\";\n// Alias the loading bar for various backwards compatibilities since the project has matured:\nangular.module(MODULE_NAME, ['cfp.loadingBarInterceptor']);\nangular.module('chieffancypants.loadingBar', ['cfp.loadingBarInterceptor']);\n\n\n/**\n * loadingBarInterceptor service\n *\n * Registers itself as an Angular interceptor and listens for XHR requests.\n */\nangular.module('cfp.loadingBarInterceptor', ['cfp.loadingBar'])\n  .config(['$httpProvider', function ($httpProvider) {\n  \n    var interceptor = ['$q', '$cacheFactory', '$timeout', '$rootScope', '$log', 'cfpLoadingBar', function ($q, $cacheFactory, $timeout, $rootScope, $log, cfpLoadingBar) {\n    \n      /**\n       * The total number of requests made\n       */\n      var reqsTotal = 0;\n    \n      /**\n       * The number of requests completed (either successfully or not)\n       */\n      var reqsCompleted = 0;\n    \n      /**\n       * The amount of time spent fetching before showing the loading bar\n       */\n      var latencyThreshold = cfpLoadingBar.latencyThreshold;\n    \n      /**\n       * $timeout handle for latencyThreshold\n       */\n      var startTimeout;\n    \n    \n      /**\n       * calls cfpLoadingBar.complete() which removes the\n       * loading bar from the DOM.\n       */\n      function setComplete() {\n        $timeout.cancel(startTimeout);\n        cfpLoadingBar.complete();\n        reqsCompleted = 0;\n        reqsTotal = 0;\n      }\n    \n      /**\n       * Determine if the response has already been cached\n       * @param  {Object}  config the config option from the request\n       * @return {Boolean} retrns true if cached, otherwise false\n       */\n      function isCached(config) {\n        var cache;\n        var defaultCache = $cacheFactory.get('$http');\n        var defaults = $httpProvider.defaults;\n      \n        // Choose the proper cache source. Borrowed from angular: $http service\n        if ((config.cache || defaults.cache) && config.cache !== false &&\n          (config.method === 'GET' || config.method === 'JSONP')) {\n          cache = angular.isObject(config.cache) ? config.cache\n            : angular.isObject(defaults.cache) ? defaults.cache\n              : defaultCache;\n        }\n      \n        var cached = cache !== undefined ?\n          cache.get(config.url) !== undefined : false;\n      \n        if (config.cached !== undefined && cached !== config.cached) {\n          return config.cached;\n        }\n        config.cached = cached;\n        return cached;\n      }\n    \n    \n      return {\n        'request': function (config) {\n          // Check to make sure this request hasn't already been cached and that\n          // the requester didn't explicitly ask us to ignore this request:\n          if (!config.ignoreLoadingBar && !isCached(config)) {\n            $rootScope.$broadcast('cfpLoadingBar:loading', {url: config.url});\n            if (reqsTotal === 0) {\n              startTimeout = $timeout(function () {\n                cfpLoadingBar.start();\n              }, latencyThreshold);\n            }\n            reqsTotal++;\n            cfpLoadingBar.set(reqsCompleted / reqsTotal);\n          }\n          return config;\n        },\n      \n        'response': function (response) {\n          if (!response || !response.config) {\n            $log.error('Broken interceptor detected: Config object not supplied in response:\\n https://github.com/chieffancypants/angular-loading-bar/pull/50');\n            return response;\n          }\n        \n          if (!response.config.ignoreLoadingBar && !isCached(response.config)) {\n            reqsCompleted++;\n            if (reqsCompleted >= reqsTotal) {\n              $rootScope.$broadcast('cfpLoadingBar:loaded', {url: response.config.url, result: response});\n              setComplete();\n            } else {\n              cfpLoadingBar.set(reqsCompleted / reqsTotal);\n            }\n          }\n          return response;\n        },\n      \n        'responseError': function (rejection) {\n          if (!rejection || !rejection.config) {\n            $log.error('Broken interceptor detected: Config object not supplied in rejection:\\n https://github.com/chieffancypants/angular-loading-bar/pull/50');\n            return $q.reject(rejection);\n          }\n        \n          if (!rejection.config.ignoreLoadingBar && !isCached(rejection.config)) {\n            reqsCompleted++;\n            if (reqsCompleted >= reqsTotal) {\n              $rootScope.$broadcast('cfpLoadingBar:loaded', {url: rejection.config.url, result: rejection});\n              setComplete();\n            } else {\n              cfpLoadingBar.set(reqsCompleted / reqsTotal);\n            }\n          }\n          return $q.reject(rejection);\n        }\n      };\n    }];\n  \n    $httpProvider.interceptors.push(interceptor);\n  }]);\n\n\n/**\n * Loading Bar\n *\n * This service handles adding and removing the actual element in the DOM.\n * Generally, best practices for DOM manipulation is to take place in a\n * directive, but because the element itself is injected in the DOM only upon\n * XHR requests, and it's likely needed on every view, the best option is to\n * use a service.\n */\nangular.module('cfp.loadingBar', [])\n  .provider('cfpLoadingBar', function () {\n    \n    this.autoIncrement = true;\n    this.includeSpinner = true;\n    this.includeBar = true;\n    this.latencyThreshold = 100;\n    this.startSize = 0.02;\n    this.parentSelector = 'body';\n    this.spinnerTemplate = '<div id=\"loading-bar-spinner\"><div class=\"spinner-icon\"></div></div>';\n    this.loadingBarTemplate = '<div id=\"loading-bar\"><div class=\"bar\"><div class=\"peg\"></div></div></div>';\n    \n    this.$get = ['$injector', '$document', '$timeout', '$rootScope', function ($injector, $document, $timeout, $rootScope) {\n      var $animate;\n      var $parentSelector = this.parentSelector,\n        loadingBarContainer = angular.element(this.loadingBarTemplate),\n        loadingBar = loadingBarContainer.find('div').eq(0),\n        spinner = angular.element(this.spinnerTemplate);\n      \n      var incTimeout,\n        completeTimeout,\n        started = false,\n        status = 0;\n      \n      var autoIncrement = this.autoIncrement;\n      var includeSpinner = this.includeSpinner;\n      var includeBar = this.includeBar;\n      var startSize = this.startSize;\n      \n      /**\n       * Inserts the loading bar element into the dom, and sets it to 2%\n       */\n      function _start() {\n        if (!$animate) {\n          $animate = $injector.get('$animate');\n        }\n        \n        $timeout.cancel(completeTimeout);\n        \n        // do not continually broadcast the started event:\n        if (started) {\n          return;\n        }\n        \n        var document = $document[0];\n        var parent = document.querySelector ?\n            document.querySelector($parentSelector)\n            : $document.find($parentSelector)[0]\n          ;\n        \n        if (!parent) {\n          parent = document.getElementsByTagName('body')[0];\n        }\n        \n        var $parent = angular.element(parent);\n        var $after = parent.lastChild && angular.element(parent.lastChild);\n        \n        $rootScope.$broadcast('cfpLoadingBar:started');\n        started = true;\n        \n        if (includeBar) {\n          $animate.enter(loadingBarContainer, $parent, $after);\n        }\n        \n        if (includeSpinner) {\n          $animate.enter(spinner, $parent, loadingBarContainer);\n        }\n        \n        _set(startSize);\n      }\n      \n      /**\n       * Set the loading bar's width to a certain percent.\n       *\n       * @param n any value between 0 and 1\n       */\n      function _set(n) {\n        if (!started) {\n          return;\n        }\n        var pct = (n * 100) + '%';\n        loadingBar.css('width', pct);\n        status = n;\n        \n        // increment loadingbar to give the illusion that there is always\n        // progress but make sure to cancel the previous timeouts so we don't\n        // have multiple incs running at the same time.\n        if (autoIncrement) {\n          $timeout.cancel(incTimeout);\n          incTimeout = $timeout(function () {\n            _inc();\n          }, 250);\n        }\n      }\n      \n      /**\n       * Increments the loading bar by a random amount\n       * but slows down as it progresses\n       */\n      function _inc() {\n        if (_status() >= 1) {\n          return;\n        }\n        \n        var rnd = 0;\n        \n        // TODO: do this mathmatically instead of through conditions\n        \n        var stat = _status();\n        if (stat >= 0 && stat < 0.25) {\n          // Start out between 3 - 6% increments\n          rnd = (Math.random() * (5 - 3 + 1) + 3) / 100;\n        } else if (stat >= 0.25 && stat < 0.65) {\n          // increment between 0 - 3%\n          rnd = (Math.random() * 3) / 100;\n        } else if (stat >= 0.65 && stat < 0.9) {\n          // increment between 0 - 2%\n          rnd = (Math.random() * 2) / 100;\n        } else if (stat >= 0.9 && stat < 0.99) {\n          // finally, increment it .5 %\n          rnd = 0.005;\n        } else {\n          // after 99%, don't increment:\n          rnd = 0;\n        }\n        \n        var pct = _status() + rnd;\n        _set(pct);\n      }\n      \n      function _status() {\n        return status;\n      }\n      \n      function _completeAnimation() {\n        status = 0;\n        started = false;\n      }\n      \n      function _complete() {\n        if (!$animate) {\n          $animate = $injector.get('$animate');\n        }\n        \n        _set(1);\n        $timeout.cancel(completeTimeout);\n        \n        // Attempt to aggregate any start/complete calls within 500ms:\n        completeTimeout = $timeout(function () {\n          var promise = $animate.leave(loadingBarContainer, _completeAnimation);\n          if (promise && promise.then) {\n            promise.then(_completeAnimation);\n          }\n          $animate.leave(spinner);\n          $rootScope.$broadcast('cfpLoadingBar:completed');\n        }, 500);\n      }\n      \n      return {\n        start: _start,\n        set: _set,\n        status: _status,\n        inc: _inc,\n        complete: _complete,\n        autoIncrement: this.autoIncrement,\n        includeSpinner: this.includeSpinner,\n        latencyThreshold: this.latencyThreshold,\n        parentSelector: this.parentSelector,\n        startSize: this.startSize\n      };\n      \n      \n    }];     //\n  });\n\nmodule.exports = MODULE_NAME;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/loading-bar.js\n// module id = 8\n// module chunks = 1"
  ],
  "sourceRoot": ""
}
